Event objects are created when something significant happens in the server.

Events are instances of subclasses of net.commerce.zocalo.ajax.events.Action, which extends org.apache.log4j.spi.LoggingEvent.  This makes it possible for them to be handed directly to a logger which causes them to be passed as an argument to the Appender's append(Event) method.

Log4j provides AppenderSkeleton, which is the prototype for Appenders that consume Events.  Zocalo's Appenders format the events and distribute them to dispatchers.  The dispatchers (net.commerce.zocalo.ajax.dispatch.Dispatcher) have a reference to a bayeux channel, and can marshall events and thereby publish them to AJAX.  There's also a MockBayeux and MockBayeuxChannel that allows Zocalo to collect events internally when necessary.

Each Appender has one or more Dispatcher.  The Appenders react to specific server-side events, and distribute them to their dispatchers.  The dispatchers represent a particular channel distributing messages for a set of clients. This allows javascript in the browser to specify which set of events it wants to consume and assign a handler method in the browser to be invoked when a message of interest arrives.

Here are three examples in detail.  PriceChange events are generated during experiments whenever there's a change is the set of bids in the book, and are used in the browser to trigger updating the candle chart displaying all the outstanding offers.  (They are distinct from Trades, which only occur when an actual trade takes place, and cause a new historical price to be displayed, and the candle moved right.)  IndividualTimingEvents are distributed directly to a particular user (a Judge) when a timer expires.  In the browser, we can then disable the judge's inputbox for entering price estimates.  This only affects one experiment subject.  The third case is used to update price charts after a trade in a prediction market.  It takes a significant amount of time to compute the price charts, so we have a separate thread generating them, and once the chart is ready, we send out an update to all the browsers viewing that market so they can request a new copy.  Since this is a simple image refresh, Jetty can handle it in parallel with the continuing market activity.

